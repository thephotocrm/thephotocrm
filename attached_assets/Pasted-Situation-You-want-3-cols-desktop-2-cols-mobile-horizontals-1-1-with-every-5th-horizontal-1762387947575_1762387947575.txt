Situation

You want: 3 cols (desktop) / 2 cols (mobile), horizontals = 1×1 with every 5th horizontal = 2×2, verticals = 1×2, no gaps. Replit’s pushback: avoid cropping and heavy JS.

Assumptions / Constraints

Photography gallery ⇒ preserving full compositions is important.

You still want occasional 2×2 “feature” tiles.

You’re on React + Tailwind + shadcn, currently CSS Grid with gridAutoRows:'min-content'.

Options / Trade-offs
1) CSS Columns / react-masonry-css (no crop, no JS calc)

Pros: super simple, zero layout JS, no cropping.

Cons: cannot truly span 2 columns for a single item (those libs split items into independent columns). Any “6-column trick” still can’t make one item occupy two columns in that system. If 2×2 features are a must, this won’t do it.

2) CSS Grid + measured row-spans (no crop)

Set tiny auto-rows, measure each tile’s natural rendered height (with img{width:100%; height:auto}), and set grid-row-end: span N.

Pros: no gaps, keeps full image (no cropping), supports true 2×2 (via col-span-2) and any other shape.

Cons: small layout script; some ResizeObserver/work on image load/resizes (can be optimized).

3) CSS Grid + fixed aspect boxes (cropped)

The version Replit flagged: uses object-cover.

Pros: hard, uniform shapes (exact 1×1, 1×2, 2×2).

Cons: crops images (likely a no-go for you).

Recommendation

Pick Option 2: CSS Grid + measured row-spans. It gives you no gaps, true 2×2 features, and no cropping. The earlier “cropping” was from using square/ratio wrappers—drop those. Let images render at natural height; compute spans from that height.

Next Actions

Grid container

Replace gridAutoRows:'min-content' with tiny rows.

Keep dense packing for fill-in.

<div
  ref={gridRef}
  className="grid grid-cols-2 lg:grid-cols-3 gap-3 lg:gap-4 auto-rows-[8px]"
  style={{ gridAutoFlow: 'dense' }}
>
  {laidOut.map((img) => (
    <Card
      key={img.id}
      className={`overflow-hidden rounded-none ${img.featured ? 'col-span-2' : 'col-span-1'}`}
      data-masonry-item
    >
      <img
        src={img.url}
        alt={img.alt ?? ''}
        className="block w-full h-auto"    // <-- no object-cover, no ratio box
        loading="lazy"
      />
    </Card>
  ))}
</div>


Mark every 5th horizontal as featured (2×2)

function layoutImages(imgs: {id:string; url:string; w:number; h:number;}[]) {
  let horiz = 0;
  return imgs.map(i => {
    const isVertical = i.h > i.w * 1.2;
    const featured = !isVertical && (++horiz % 5 === 0); // every 5th horizontal
    return { ...i, isVertical, featured };
  });
}
const laidOut = layoutImages(imagesWithDimensions);


Span rows by measured height (no crop)

import { useEffect, useRef } from 'react';

const ROW = 8;                 // matches auto-rows-[8px]
const GAP_SM = 12;             // gap-3
const GAP_LG = 16;             // lg:gap-4

function useMasonryGrid() {
  const ref = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const grid = ref.current;
    if (!grid) return;

    let GAP = window.matchMedia('(min-width:1024px)').matches ? GAP_LG : GAP_SM;

    const items = Array.from(grid.querySelectorAll<HTMLElement>('[data-masonry-item]'));
    const setSpan = (el: HTMLElement) => {
      // height of the img (natural aspect, no crop)
      const img = el.querySelector('img') as HTMLImageElement | null;
      if (!img) return;
      const h = img.getBoundingClientRect().height;
      const rows = Math.ceil((h + GAP) / (ROW + GAP));
      el.style.gridRowEnd = `span ${rows}`;
    };

    const refresh = () => items.forEach(setSpan);

    // Recalc on image load
    items.forEach(el => {
      const img = el.querySelector('img') as HTMLImageElement | null;
      if (!img) return;
      if (img.complete) setSpan(el);
      else img.addEventListener('load', () => setSpan(el), { once: true });
    });

    // Recalc on container resize (not every node)
    const ro = new ResizeObserver(refresh);
    ro.observe(grid);

    // Update gap on breakpoint change
    const mq = window.matchMedia('(min-width:1024px)');
    const onMQ = () => { GAP = mq.matches ? GAP_LG : GAP_SM; refresh(); };
    mq.addEventListener?.('change', onMQ);

    // Also handle window resize end (throttled)
    let t: number | undefined;
    const onResize = () => { clearTimeout(t); t = window.setTimeout(refresh, 100); };
    window.addEventListener('resize', onResize);

    return () => {
      ro.disconnect();
      mq.removeEventListener?.('change', onMQ);
      window.removeEventListener('resize', onResize);
    };
  }, []);

  return ref;
}


Use it:

const gridRef = useMasonryGrid();


Ensure featured horizontals are wide

They already get col-span-2 (desktop).

On mobile (2 cols), col-span-2 makes them full-width naturally.

Vertical items remain col-span-1; their height is whatever their image dictates (no crop).

If you still want verticals to read visually “1×2”, feed reasonably tall originals or add max-height clamp per breakpoint.

Risks

If ROW/gap constants diverge from Tailwind classes, you’ll see micro misalignments. Keep them in sync.

There’s still a small layout cost on image load/resize (bounded to the grid, not each item via RO). For large galleries, consider server-sending dimensions and setting an inline style={{aspectRatio: w/h}} on the <img> to avoid jank while it loads (still no crop).

Open Questions

Do you want strict “vertical = 1×2” box heights (identical height for all verticals)? That requires cropping (or letterboxing). If you truly want no crop, vertical heights will naturally vary.